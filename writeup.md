Fastest Run: https://www.gradescope.com/courses/760173/assignments/4536922/submissions/256854717
For this lab, the goal was to traverse a 3D map using graph traversal algorithms. The map was given as strings of hexadecimal numbers which signified if a block was an "air" or "stone" block. To store the map we used a 3 dimensional array and converted the hex into map blocks using a switch statement to speed up the map creation. The map holds a struct "Voxel" which itself holds the point location (z,y,x), the fall value (-1 = stone block)and the parent node (node from which the current node was seen). To perform the searching, we used a simple breadth first search which would avoid pushing blocks into the queue which had already been maked as "seen". The breadth first search algorith would look north, south, east, and west to find valid blocks which were either directly in front, a fall away, or a jump away. If a block had been "seen", the algorithm would not push it into the stack to reduce the memory the queue took up. Additionally falls which would lead to being outside the bounds of the map were marked with a very large number so the algorithm could avoid the fall. Once the target block was searched by a node when looking for its valid children, the program would end the search and start to backtrack from the target block, following the parent points, until it reached the start. This path was stored by pushing to the front of a vector and then returning the vector. While pathfinding, we also stored the pointers to visited voxels in a linked list so we could reset the map after each run by looping through the list and returning the voxel variables to the default. The data structures used were a 3D array to store the map, a linked list to store the pointers to visited nodes and a queue to hold nodes which need to be searched. The creation of the map was O(n) since each element is searched once. The clearing of the map was O(n) as each element in the map which was searched had to be reseted individually. The searching of each node and its neighbors is also O(n) since each element in the queue is searched and possibly the map. The path tracing is O(n) since each element that leads to the path is searched. Looking up nodes is O(1) since finding a array element is O(1) and the nodes are stored in an array. Our fastest time was 33.73 seconds with an average runtime of 43 seconds.